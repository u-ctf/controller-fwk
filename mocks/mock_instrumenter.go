// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/u-ctf/controller-fwk/instrument (interfaces: Instrumenter)
//
// Generated by this command:
//
//	mockgen -destination=./mocks/mock_instrumenter.go -package mocks github.com/u-ctf/controller-fwk/instrument Instrumenter
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	logr "github.com/go-logr/logr"
	trace "go.opentelemetry.io/otel/trace"
	gomock "go.uber.org/mock/gomock"
	workqueue "k8s.io/client-go/util/workqueue"
	controllerruntime "sigs.k8s.io/controller-runtime"
	client "sigs.k8s.io/controller-runtime/pkg/client"
	handler "sigs.k8s.io/controller-runtime/pkg/handler"
	reconcile "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// MockInstrumenter is a mock of Instrumenter interface.
type MockInstrumenter struct {
	ctrl     *gomock.Controller
	recorder *MockInstrumenterMockRecorder
	isgomock struct{}
}

// MockInstrumenterMockRecorder is the mock recorder for MockInstrumenter.
type MockInstrumenterMockRecorder struct {
	mock *MockInstrumenter
}

// NewMockInstrumenter creates a new mock instance.
func NewMockInstrumenter(ctrl *gomock.Controller) *MockInstrumenter {
	mock := &MockInstrumenter{ctrl: ctrl}
	mock.recorder = &MockInstrumenterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInstrumenter) EXPECT() *MockInstrumenterMockRecorder {
	return m.recorder
}

// Cleanup mocks base method.
func (m *MockInstrumenter) Cleanup(ctx *context.Context, req reconcile.Request) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Cleanup", ctx, req)
}

// Cleanup indicates an expected call of Cleanup.
func (mr *MockInstrumenterMockRecorder) Cleanup(ctx, req any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Cleanup", reflect.TypeOf((*MockInstrumenter)(nil).Cleanup), ctx, req)
}

// GetContextForEvent mocks base method.
func (m *MockInstrumenter) GetContextForEvent(event any) *context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContextForEvent", event)
	ret0, _ := ret[0].(*context.Context)
	return ret0
}

// GetContextForEvent indicates an expected call of GetContextForEvent.
func (mr *MockInstrumenterMockRecorder) GetContextForEvent(event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContextForEvent", reflect.TypeOf((*MockInstrumenter)(nil).GetContextForEvent), event)
}

// GetContextForRequest mocks base method.
func (m *MockInstrumenter) GetContextForRequest(req reconcile.Request) (*context.Context, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetContextForRequest", req)
	ret0, _ := ret[0].(*context.Context)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// GetContextForRequest indicates an expected call of GetContextForRequest.
func (mr *MockInstrumenterMockRecorder) GetContextForRequest(req any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetContextForRequest", reflect.TypeOf((*MockInstrumenter)(nil).GetContextForRequest), req)
}

// InstrumentRequestHandler mocks base method.
func (m *MockInstrumenter) InstrumentRequestHandler(arg0 handler.TypedEventHandler[client.Object, reconcile.Request]) handler.TypedEventHandler[client.Object, reconcile.Request] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstrumentRequestHandler", arg0)
	ret0, _ := ret[0].(handler.TypedEventHandler[client.Object, reconcile.Request])
	return ret0
}

// InstrumentRequestHandler indicates an expected call of InstrumentRequestHandler.
func (mr *MockInstrumenterMockRecorder) InstrumentRequestHandler(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstrumentRequestHandler", reflect.TypeOf((*MockInstrumenter)(nil).InstrumentRequestHandler), arg0)
}

// NewLogger mocks base method.
func (m *MockInstrumenter) NewLogger(ctx context.Context) logr.Logger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewLogger", ctx)
	ret0, _ := ret[0].(logr.Logger)
	return ret0
}

// NewLogger indicates an expected call of NewLogger.
func (mr *MockInstrumenterMockRecorder) NewLogger(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewLogger", reflect.TypeOf((*MockInstrumenter)(nil).NewLogger), ctx)
}

// NewQueue mocks base method.
func (m *MockInstrumenter) NewQueue(mgr controllerruntime.Manager) func(string, workqueue.TypedRateLimiter[reconcile.Request]) workqueue.TypedRateLimitingInterface[reconcile.Request] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewQueue", mgr)
	ret0, _ := ret[0].(func(string, workqueue.TypedRateLimiter[reconcile.Request]) workqueue.TypedRateLimitingInterface[reconcile.Request])
	return ret0
}

// NewQueue indicates an expected call of NewQueue.
func (mr *MockInstrumenterMockRecorder) NewQueue(mgr any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewQueue", reflect.TypeOf((*MockInstrumenter)(nil).NewQueue), mgr)
}

// StartSpan mocks base method.
func (m *MockInstrumenter) StartSpan(globalCtx *context.Context, localCtx context.Context, spanName string, opts ...trace.SpanStartOption) (context.Context, trace.Span) {
	m.ctrl.T.Helper()
	varargs := []any{globalCtx, localCtx, spanName}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "StartSpan", varargs...)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(trace.Span)
	return ret0, ret1
}

// StartSpan indicates an expected call of StartSpan.
func (mr *MockInstrumenterMockRecorder) StartSpan(globalCtx, localCtx, spanName any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{globalCtx, localCtx, spanName}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartSpan", reflect.TypeOf((*MockInstrumenter)(nil).StartSpan), varargs...)
}
